---
layout: post
title: "ES6"
date_time: "2016-04-24 23:35:12 +0800"
description: ""
category:
- programming
tags:
---
{% include JB/setup %}

阅读阮一峰老师的[《ECMAScript 6入门》](http://es6.ruanyifeng.com/)

### let 和 const

1. temporal dead zone 为了防止运行时错误，防止在变量声明前就使用了这个变量，从而导致意料之外。
2. let 块级作用域可以减少很多潜在的危害，比如说 for 循环里定义的 i，还有 switch 里定义的变量，出了这一块作用域就不应该被用到。

{% highlight JavaScript linenos %}
{
	let insane = 'Hello World0'; console.log('0', insane);
	{
		let insane = 'Hello World1'; console.log('1', insane);
	}
	console.log('2', insane);
}
{% endhighlight %}

ES6 的函数作用域也是块级作用域。

const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变。
有坑，如果
{% highlight JavaScript linenos %}
const foo = {};
foo.prop = 123;

const a = [];
a.push("Hello"); // 可执行
a.length = 0;    // 可执行
a = ["Dave"];    // 报错
{% endhighlight %}

可以用 `const foo = Object.freeze({});`

对象属性彻底冻结
{% highlight JavaScript linenos %}
let constantize = (obj) => {
	Object.freeze(obj);
	Object.keys(obj).forEach( (key, value) => {
		if ( typeof obj[key] === 'object' ) {
			constantize( obj[key] );
		}
	});
};
{% endhighlight %}

### 不能使用圆括号

- 变量生命语句种，不能带有圆括号
- 函数参数中，模式不能带有圆括号
- 赋值语句中，不能将整个模式，或嵌套模式中的一层，防止圆括号之中

### 变量的解构赋值总结

- 数组的解构赋值
- 对象
- 字符串
- 数值和布尔值
- 函数参数
- 圆括号
- 用途


### Unicode

	"\u0061"
	// "a"

PS: 编码问题是一个比较大的坑，占坑不说
<http://es6.ruanyifeng.com/#docs/string>

### 正则

第一个参数是正则对象，第二个参数是指定修饰符。

	new RegExp(/abc/ig, 'i').flags

四个字节的 UTF-16 需要使用 u 修饰符。

点（.）字符在正则表达式中，表示的是除了换行符（\n）外的任意单个字符。但是对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。

	var s = '𠮷';
	/^.$/.test(s) // false
	/^.$/u.test(s) // true

大括号可以表示 Unicode 字符

	/\u{61}/.test('a') // false
	/\u{61}/u.test('a') // true

`\s` 匹配所有空格字符，`\S` 预定义模式，匹配所有不是空格的字符，加了 u 修饰符才能正确匹配码点大于 0xFFFF 的 Unicode 字符。

	function codePointLength(text) {
		var result = text.match(/[\s\S]/gu);
		return result ? result.length : 0;
	}

	var s = '𠮷𠮷';

	s.length // 4
	codePointLength(s) // 2

i 修饰符：大小写不敏感的匹配。

y 修饰符：我理解的是变成 /^xx/ 的正则表达式。

	// 没有找到匹配
	'x##'.split(/#/y)
	// [ 'x##' ]

	// 找到两个匹配
	'##x'.split(/#/y)
	// [ '', '', 'x' ]

	'##x'.split(/^#/)
	// ["", "#x"]

	'##x'.split(/^#/g)
	// ["", "#x"]

flags属性

	// ES5的source属性
	// 返回正则表达式的正文
	/abc/ig.source
	// "abc"

	// ES6的flags属性
	// 返回正则表达式的修饰符
	/abc/ig.flags
	// 'gi'

字符串转义

	function escapeRegExp(str) {
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	}

	let str = '/path/to/resource.html?search=query';
	escapeRegExp(str)

JavaScript 只支持先行断言与先行否定断言，不支持后行断言（lookbehind）和后行否定断言。
『先行断言（lookahead）』指的是，x 只有在 y 前面才匹配，必须写成 /x(?=y)/。
『先行否定断言（negative lookahead）』/x(?!y)/。

	/\d+(?=%)/.exec('100% of US presidents have been male')  // ["100"]
	/\d+(?!%)/.exec('that’s all 44 of them')                 // ["44"]

『experiment JavaScript features』开关 enable（地址栏：about:flags）
『后行断言』，x 只有在 y 后面才匹配，必须写成 /(?<=y)x/。

	/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]
	/(?<!\$)\d+/.exec('it’s is worth about €90')                // ["90"]

continue ....
